// @title           Media Server API
// @version         1.0
// @description     This is the API for my media streaming server
// @termsOfService  http://example.com/terms/

// @contact.name   Benson
// @contact.email  nwankwobenson29@gmail.com

// @license.name  MIT
// @license.url   https://opensource.org/licenses/MIT

// @host      localhost:8000
// @BasePath  /
package main

import (
	"bufio"
	"context"
	"fmt"
	database "media_server/internal/db"
	handlers "media_server/internal/handlers"
	"media_server/internal/logger"
	"media_server/internal/media"
	"net"
	"net/http"
	"os"
	"sync"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/cors"
	"github.com/gorilla/websocket"
	"go.uber.org/zap"

	_ "media_server/docs" // docs generated by swag init

	httpSwagger "github.com/swaggo/http-swagger"
)

var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool { return true },
}

func main() {
	var wg sync.WaitGroup
	wg.Add(2)
	logger.InitLogger(true)
	defer logger.Log().Sync()
	media.SetConfigPath("config.json")

	config, err := media.LoadConfig()
	if err != nil {
		logger.Log().Sugar().Error("failed to load config")
	}
	logger.Log().Sugar().Info("loaded config sucesfully")

	media_files, err := config.ScanMediaDirs()
	if err != nil {
		logger.Log().Sugar().Errorf("failed to scan media %v\n", err)
		return
	}

	dbObj := database.InitDataBase("media.db")

	if dbObj.Err != nil {
		logger.Log().Sugar().Errorf("failed to create db: %v \n", err)
		return
	}

	logger.Log().Info("Syncing database")
	if err := dbObj.SyncDatabase(&media_files); err != nil {
		logger.Log().Sugar().Panicf("failed to sync db: %v", err)
		return
	}

	addrs, err := net.InterfaceAddrs()
	if err != nil {
		logger.Log().Sugar().Errorf("failed to get network interfaces: %v", err)
		return
	}
	var allowedOrigin string
	var allowedOrigin2 string
	for _, addr := range addrs {
		if ipNet, ok := addr.(*net.IPNet); ok && !ipNet.IP.IsLoopback() {
			if ip := ipNet.IP.To4(); ip != nil {
				allowedOrigin = fmt.Sprintf("http://%s:4173", ip.String())
				allowedOrigin2 = fmt.Sprintf("http://%s:5173", ip.String())
				break
			}
		}
	}
	if allowedOrigin == "" {
		panic("no local IP found")
	}
	router := chi.NewRouter()
	srv := &http.Server{
		Addr:    ":8000",
		Handler: router, // your chi router
	}
	handle := handlers.Handler{DB: &dbObj, Logger: logger.Log()}

	go func() {
		defer wg.Done()

		router.Use(cors.Handler(cors.Options{
			// AllowedOrigins:   []string{"https://foo.com"}, // Use this to allow specific origin hosts
			AllowedOrigins: []string{"http://localhost:5173", "http://127.0.0.1:5173", "http://localhost:4173", "http://127.0.0.1:4173", allowedOrigin, allowedOrigin2, "http://127.0.0.1:8000", "http://localhost:8000", "http://localhost:8080"},
			Debug:          true,
			// AllowOriginFunc:  func(r *http.Request, origin string) bool { return true },
			AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
			AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
			ExposedHeaders:   []string{"Link"},
			AllowCredentials: false,
			MaxAge:           86400, // Maximum value not ignored by any of major browsers
		}))
		router.Get("/media/all", handle.GetAll)
		router.Get("/media/{id}/stream", handle.StreamMedia)
		router.Get("/media/paginated", handle.GetPaginatedHandler)
		router.Get("/media/{id}", handle.GetByID)
		router.Get("/media/{id}/thumbnail", handle.ThumbnailHandler)
		router.Get("/docs/*", httpSwagger.Handler(
			httpSwagger.URL("http://localhost:8000/docs/doc.json"), // CORRECT
		))

		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			logger.Log().Sugar().Errorf("server failed to start %v\n", err)
			return
		}
	}()
	wsRouter := chi.NewRouter()
	wssrv := &http.Server{
		Addr:         ":9000",
		Handler:      wsRouter,
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
	}

	go func() {
		defer wg.Done()

		wsRouter.Get("/ws", func(w http.ResponseWriter, r *http.Request) {
			conn, err := upgrader.Upgrade(w, r, nil)
			if err != nil {
				http.Error(w, "Failed to upgrade", http.StatusInternalServerError)
				return
			}
			defer conn.Close()
			handle.MediaConfigWS(conn)
		})

		logger.Log().Info("WebSocket server running on :9000")
		if err := wssrv.ListenAndServe(); err != nil {
			logger.Log().Sugar().Fatalf("WebSocket server failed: %v", err)
		}
	}()

	logger.Log().Info("Press 'q' then ENTER to quit.")

	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		text := scanner.Text()
		if text == "q" || text == "Q" {
			logger.Log().Info("Quitting!")
			ShutdownServers([]*http.Server{srv, wssrv})
			wg.Wait()
			break
		}
		logger.Log().Info("You typed:", zap.String("input", text))
	}

	if err := scanner.Err(); err != nil {
		logger.Log().Error("Error reading input", zap.Error(err))
	}

}
func ShutdownServers(servers []*http.Server) error {
	logger.Log().Info("Shutting down servers gracefully...")

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var wg sync.WaitGroup
	wg.Add(len(servers))

	var mu sync.Mutex
	var firstErr error

	for _, srv := range servers {
		go func(s *http.Server) {
			defer wg.Done()
			if err := s.Shutdown(ctx); err != nil {
				logger.Log().Sugar().Errorf("Server shutdown error: %v", err)
				mu.Lock()
				if firstErr == nil {
					firstErr = err
				}
				mu.Unlock()
			}
		}(srv)
	}

	wg.Wait()

	if firstErr != nil {
		return firstErr
	}

	logger.Log().Info("All servers shutdown complete")
	return nil
}
